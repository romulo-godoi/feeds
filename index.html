<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leitor de Feeds RSS Moderno com Firebase Sync</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <script type="module">
      // Import the functions you need from the SDKs you need
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
      import { getDatabase, ref, onValue, set, get, off } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js"; // Added 'off'

      // Make Firebase app and functions globally available for the main script
      window.fbServices = {
        initializeApp,
        getDatabase,
        ref,
        onValue,
        set,
        get,
        off // Make 'off' available
      };

      // Your web app's Firebase configuration
      window.firebaseConfigGlobal = {
        apiKey: "AIzaSyBNvHd_F9dencQnVHmPuL9CkGihyV8Swmg",
        authDomain: "feeds-31fd9.firebaseapp.com",
        databaseURL: "https://feeds-31fd9-default-rtdb.firebaseio.com",
        projectId: "feeds-31fd9",
        storageBucket: "feeds-31fd9.appspot.com",
        messagingSenderId: "80337441090",
        appId: "1:80337441090:web:b728dbbb105ccca9b338db"
      };
    </script>
</head>
<body>

    <div id="seedModal" class="hidden">
        <div class="modal-dialog">
            <div class="modal-header">
                <h2>Configurar Sincronização</h2>
                <button id="closeSeedModalButton" style="display:none;">&times;</button> </div>
            <div class="modal-body">
                <p>Para sincronizar seus feeds e status de leitura entre dispositivos, insira sua "seed" (chave de sincronização) ou gere uma nova.</p>
                <div class="form-group">
                    <label for="existingSeedInput">Seed Existente (ex: palavra-123):</label>
                    <input type="text" id="existingSeedInput" placeholder="palavra-123">
                    <button id="useExistingSeedButton" class="button-primary">Usar Seed</button>
                </div>
                <hr style="margin: 20px 0;">
                <div class="form-group">
                    <p>Ou, se não tiver uma seed, gere uma nova:</p>
                    <button id="generateNewSeedButton" class="button-secondary">Gerar Nova Seed</button>
                    <p id="generatedSeedDisplay" class="hidden" style="margin-top:10px; font-weight:bold;"></p>
                </div>
                <p id="seedError" class="error-message-item hidden" style="margin-top:15px;"></p>
            </div>
        </div>
    </div>

    <button id="sidebarToggle">
        <svg id="sidebarToggleIconOpen" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 6h16M4 12h16M4 18h16"></path></svg>
        <svg id="sidebarToggleIconClose" class="hidden" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 18L18 6M6 6l12 12"></path></svg>
    </button>

    <div id="sidebar">
        <div id="currentSeedDisplayWrapper" class="hidden" style="padding: 5px 10px; background-color: #e9ecef; border-radius: 4px; margin-bottom: 15px; text-align: center; font-size: 0.85em;">
            Seed: <strong id="activeSeedValue"></strong>
            <button id="changeSeedButton" style="margin-left: 10px; font-size: 0.8em; padding: 2px 5px;">Mudar</button>
        </div>
        <div class="sidebar-controls">
            <input type="file" id="opmlImportInput" accept=".opml, .xml" class="hidden">
            <button id="opmlImportButton">Importar OPML</button>
            <button id="toggleAddFeedFormButton">Adicionar Novo Feed</button>
            <div id="addFeedForm" class="hidden">
                <input type="url" id="sidebarNewFeedUrlInput" placeholder="URL do Feed">
                <input type="text" id="sidebarNewFeedNameInput" placeholder="Nome (opcional)">
                <button id="sidebarAddFeedButton">Adicionar</button>
            </div>
        </div>

        <div class="sidebar-section-title">Fontes</div>
        <div id="sidebarFeedListContainer">
            </div>
    </div>

    <div id="main-content">
        <div class="container">
            <div id="loading" class="hidden">
                <svg class="animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <p>Carregando e organizando feeds...</p>
            </div>
            <div id="firebaseLoading" class="hidden">
                 <svg class="animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <p>Sincronizando com a nuvem...</p>
            </div>

            <div id="feeds-container">
                </div>

            <div id="error-messages">
                </div>
        </div>
    </div>

    <div id="feedItemModal" class="hidden">
        <div class="modal-dialog">
            <div class="modal-header">
                <h2 id="modalTitle"></h2>
                <button id="closeModalButton">&times;</button>
            </div>
            <div id="modalContent">
                </div>
            <div class="modal-footer-actions">
                <button id="modalMarkAsReadButton"></button>
                <a id="modalOriginalLink" href="#" target="_blank" rel="noopener noreferrer">
                    Ler no site original
                </a>
            </div>
        </div>
    </div>

    <div id="editSourceModal" class="hidden">
        <div class="modal-dialog">
            <div class="modal-header">
                <h2 id="editSourceModalTitle">Editar Fonte</h2>
                <button id="closeEditSourceModalButton">&times;</button>
            </div>
            <div class="modal-body">
                <div>
                    <label for="editSourceNameInput">Nome da Fonte</label>
                    <input type="text" id="editSourceNameInput">
                </div>
                <input type="hidden" id="editSourceUrlHidden">
            </div>
            <div class="modal-footer-actions">
                <button id="cancelEditSourceButton">Cancelar</button>
                <button id="saveEditSourceButton">Salvar Alterações</button>
            </div>
        </div>
    </div>

    <div id="deleteConfirmationModal" class="hidden">
        <div class="modal-dialog">
            <div class="modal-header">
                <h2 id="deleteConfirmationModalTitle">Confirmar Exclusão</h2>
                <button id="closeDeleteConfirmationModalButton">&times;</button>
            </div>
            <div class="modal-body">
                <p>Você tem certeza que deseja excluir esta fonte de feed? Esta ação não pode ser desfeita.</p>
                <p><strong>Nome do Feed:</strong> <span id="feedNameToDelete"></span></p>
            </div>
            <div class="modal-footer-actions">
                <button id="cancelDeleteFeedButton">Cancelar</button>
                <button id="confirmDeleteFeedButton">Excluir</button>
            </div>
        </div>
    </div>

    <div id="toast-notification" class="hidden">
        <p id="toast-message"></p>
    </div>

    <script>
        // Firebase Global Variables
        let firebaseApp = null;
        let database = null;
        let currentUserSeed = null;
        let isSyncing = false;
        let localDataHash = "";
        let lastKnownFirebaseDataHash = "";
        let firebaseListenerAttached = false;
        let currentDbRef = null;

        // Global Variables
        let feedSources = [];
        let currentlyDisplayedFeedUrl = null;
        let readItems = {};
        let currentItemInModal = null;
        let toastTimeout = null;
        let feedUrlToDelete = null;

        // DOM Elements
        const feedsContainer = document.getElementById('feeds-container');
        const loadingIndicator = document.getElementById('loading');
        const firebaseLoadingIndicator = document.getElementById('firebaseLoading');
        const errorMessagesContainer = document.getElementById('error-messages');
        const feedItemModal = document.getElementById('feedItemModal');
        const modalTitleEl = document.getElementById('modalTitle');
        const modalContent = document.getElementById('modalContent');
        const modalOriginalLink = document.getElementById('modalOriginalLink');
        const closeModalButton = document.getElementById('closeModalButton');
        const modalMarkAsReadButton = document.getElementById('modalMarkAsReadButton');
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebarToggle');
        const sidebarToggleIconOpen = document.getElementById('sidebarToggleIconOpen');
        const sidebarToggleIconClose = document.getElementById('sidebarToggleIconClose');
        const mainContent = document.getElementById('main-content');
        const toggleAddFeedFormButton = document.getElementById('toggleAddFeedFormButton');
        const addFeedForm = document.getElementById('addFeedForm');
        const sidebarNewFeedUrlInput = document.getElementById('sidebarNewFeedUrlInput');
        const sidebarNewFeedNameInput = document.getElementById('sidebarNewFeedNameInput');
        const sidebarAddFeedButton = document.getElementById('sidebarAddFeedButton');
        const sidebarFeedListContainer = document.getElementById('sidebarFeedListContainer');
        const editSourceModal = document.getElementById('editSourceModal');
        const editSourceNameInput = document.getElementById('editSourceNameInput');
        const editSourceUrlHidden = document.getElementById('editSourceUrlHidden');
        const closeEditSourceModalButton = document.getElementById('closeEditSourceModalButton');
        const cancelEditSourceButton = document.getElementById('cancelEditSourceButton');
        const saveEditSourceButton = document.getElementById('saveEditSourceButton');
        const toastNotification = document.getElementById('toast-notification');
        const toastMessage = document.getElementById('toast-message');
        const opmlImportButton = document.getElementById('opmlImportButton');
        const opmlImportInput = document.getElementById('opmlImportInput');
        const deleteConfirmationModal = document.getElementById('deleteConfirmationModal');
        const closeDeleteConfirmationModalButton = document.getElementById('closeDeleteConfirmationModalButton');
        const cancelDeleteFeedButton = document.getElementById('cancelDeleteFeedButton');
        const confirmDeleteFeedButton = document.getElementById('confirmDeleteFeedButton');
        const feedNameToDeleteSpan = document.getElementById('feedNameToDelete');
        const seedModal = document.getElementById('seedModal');
        const closeSeedModalButton = document.getElementById('closeSeedModalButton');
        const existingSeedInput = document.getElementById('existingSeedInput');
        const useExistingSeedButton = document.getElementById('useExistingSeedButton');
        const generateNewSeedButton = document.getElementById('generateNewSeedButton');
        const generatedSeedDisplay = document.getElementById('generatedSeedDisplay');
        const seedError = document.getElementById('seedError');
        const currentSeedDisplayWrapper = document.getElementById('currentSeedDisplayWrapper');
        const activeSeedValue = document.getElementById('activeSeedValue');
        const changeSeedButton = document.getElementById('changeSeedButton');

        // Constants
        const CACHE_KEY_PREFIX = 'feed_cache_v6_img_';
        const CACHE_DURATION_MS = 72 * 60 * 60 * 1000; // 3 days for general cache validity if network fails
        const READ_ITEM_EXPIRY_MS = 72 * 60 * 60 * 1000; // 3 days for read status cleanup
        const PLACEHOLDER_IMAGE = 'https://placehold.co/600x400/EEE/CCC?text=Sem+Imagem';
        const MAX_FEEDS_DISPLAY = 35; // Max items to show on screen at once
        const FEED_SOURCES_STORAGE_KEY_OLD = 'rss_feed_reader_sources_v6_img';
        const READ_ITEMS_STORAGE_KEY_OLD = 'rss_feed_reader_read_items_v3_img';
        const SEED_STORAGE_KEY = 'rss_feed_reader_sync_seed_v1';
        const SEED_PATTERN = /^[a-zA-ZçÇãÃõÕáÁéÉíÍóÓúÚ\s]+-\d{3}$/;
        const SEED_WORDS = ["sol", "lua", "rio", "mar", "flor", "paz", "luz", "cor", "som", "vida", "amor", "casa", "pedra", "vento", "chuva", "fogo", "terra", "arvore", "canto", "alpha", "beta", "omega", "delta", "gama", "epsilon", "zeta", "eta", "theta", "iota", "kappa", "lambda", "sigma", "estrela", "nuvem", "sonho", "tempo", "espaco", "mente", "alma", "forca", "honra", "gloria", "sabio", "justo", "livro", "chave", "porta", "ponte", "jardim", "monte", "vale", "fonte", "brisa", "calma", "sereno", "amigo", "irmao"];

        function sanitizeFirebaseKey(key) {
            if (typeof key !== 'string') return '';
            return key.replace(/[.#$[\]\/]/g, '_');
        }

        function showToast(message, type = 'info', duration = 3500) {
            if (toastTimeout) clearTimeout(toastTimeout);
            toastMessage.textContent = message;
            toastNotification.className = 'toast-notification';
            if (type === 'error') toastNotification.classList.add('toast-error');
            else if (type === 'success') toastNotification.classList.add('toast-success');
            else toastNotification.classList.add('toast-info');
            toastNotification.classList.remove('hidden');
            requestAnimationFrame(() => toastNotification.classList.add('opacity-100'));
            toastTimeout = setTimeout(() => {
                toastNotification.classList.remove('opacity-100');
                setTimeout(() => toastNotification.classList.add('hidden'), 300);
            }, duration);
        }

        function getItemId(item) {
            let id = (item.guid && typeof item.guid === 'string' && item.guid.trim() !== '') ? item.guid : item.link;
            return sanitizeFirebaseKey(id || '');
        }

        function showSeedModal() {
            seedModal.classList.remove('hidden');
            requestAnimationFrame(() => seedModal.classList.add('modal-visible'));
            document.body.style.overflow = 'hidden';
        }

        function hideSeedModal() {
            seedModal.classList.remove('modal-visible');
            setTimeout(() => seedModal.classList.add('hidden'), 300);
            document.body.style.overflow = 'auto';
            seedError.classList.add('hidden');
            existingSeedInput.value = '';
            generatedSeedDisplay.classList.add('hidden');
        }

        function displayCurrentSeedElement(seed) {
            if (seed) {
                activeSeedValue.textContent = seed;
                currentSeedDisplayWrapper.classList.remove('hidden');
            } else {
                currentSeedDisplayWrapper.classList.add('hidden');
            }
        }

        function generateRandomSeed() {
            const randomWord = SEED_WORDS[Math.floor(Math.random() * SEED_WORDS.length)];
            const randomNumber = String(Math.floor(Math.random() * 900) + 100);
            return `${randomWord}-${randomNumber}`;
        }

        async function handleSeedConfiguration(seed) {
            if (!SEED_PATTERN.test(seed)) {
                seedError.textContent = 'Formato da seed inválido. Use "palavra-123".';
                seedError.classList.remove('hidden');
                return;
            }
            currentUserSeed = seed;
            localStorage.setItem(SEED_STORAGE_KEY, seed);
            displayCurrentSeedElement(seed);
            hideSeedModal();
            showToast(`Seed "${seed}" configurada. Iniciando sincronização...`, "info");
            await initializeAppLogic();
        }

        generateNewSeedButton.addEventListener('click', () => {
            const newSeed = generateRandomSeed();
            // Directly use the new seed
            handleSeedConfiguration(newSeed);
            // Optionally, still display it if handleSeedConfiguration doesn't update the UI immediately
            // before hiding, or if you want the user to see it briefly before modal closes.
            // However, handleSeedConfiguration already calls displayCurrentSeedElement and showToast.
            // So, generatedSeedDisplay and existingSeedInput might not be strictly needed here anymore
            // if the modal closes very quickly. For safety, we can leave the input population.
            existingSeedInput.value = newSeed; // Keep this so user sees the seed if they reopen.
            generatedSeedDisplay.textContent = `Sua nova seed: ${newSeed}`; // Keep for clarity if modal is reopened.
            generatedSeedDisplay.classList.remove('hidden');
            seedError.classList.add('hidden');
        });

        useExistingSeedButton.addEventListener('click', () => {
            const seed = existingSeedInput.value.trim();
            if (seed) {
                handleSeedConfiguration(seed);
            } else {
                seedError.textContent = 'Por favor, insira uma seed ou gere uma nova.';
                seedError.classList.remove('hidden');
            }
        });

        changeSeedButton.addEventListener('click', () => {
            if (confirm("Mudar a seed fará com que você perca a sincronização com os dados atuais, a menos que você reinsira a seed antiga depois. Deseja continuar?")) {
                if (firebaseListenerAttached && currentDbRef && window.fbServices.off) {
                    window.fbServices.off(currentDbRef);
                    console.log("Listener do Firebase removido da seed antiga:", localStorage.getItem(SEED_STORAGE_KEY));
                }
                currentUserSeed = null;
                firebaseListenerAttached = false;
                currentDbRef = null;

                localStorage.removeItem(SEED_STORAGE_KEY);
                feedSources = [];
                readItems = {};
                localDataHash = "";
                lastKnownFirebaseDataHash = "";
                renderSidebarFeedList();
                loadFeeds();
                displayCurrentSeedElement(null);
                showSeedModal();
            }
        });

        async function initializeFirebase() {
            if (!firebaseApp && window.fbServices && window.firebaseConfigGlobal) {
                try {
                    firebaseApp = window.fbServices.initializeApp(window.firebaseConfigGlobal);
                    database = window.fbServices.getDatabase(firebaseApp);
                    console.log("Firebase inicializado.");
                    return true;
                } catch (error) {
                    console.error("Erro ao inicializar Firebase:", error);
                    showToast("Falha ao conectar com o serviço de sincronização.", "error");
                    return false;
                }
            }
            return database != null;
        }

        async function loadInitialDataFromFirebase() {
            if (!currentUserSeed || !database) return false;
            firebaseLoadingIndicator.classList.remove('hidden');
            const dbRefPath = 'seeds/' + currentUserSeed;
            currentDbRef = window.fbServices.ref(database, dbRefPath);

            try {
                const snapshot = await window.fbServices.get(currentDbRef);
                if (snapshot.exists()) {
                    const firebaseData = snapshot.val();
                    feedSources = firebaseData.feedSources || [];
                    readItems = firebaseData.readItems || {};

                    const sanitizedReadItems = {};
                    for (const key in readItems) {
                        sanitizedReadItems[sanitizeFirebaseKey(key)] = readItems[key];
                    }
                    readItems = sanitizedReadItems;

                    localDataHash = JSON.stringify({ feedSources, readItems });
                    lastKnownFirebaseDataHash = localDataHash;
                    console.log("Dados carregados do Firebase.");
                    showToast("Dados sincronizados da nuvem.", "success", 2000);
                } else {
                    console.log("Nenhum dado na nuvem para esta seed. Verificando localStorage antigo...");
                    const storedSourcesText = localStorage.getItem(FEED_SOURCES_STORAGE_KEY_OLD);
                    if (storedSourcesText) {
                        const parsedSources = JSON.parse(storedSourcesText);
                        feedSources = parsedSources.map(s => ({
                            url: s.url,
                            name: s.name || (s.url ? new URL(s.url).hostname : 'Nome Desconhecido'),
                        }));
                    } else { feedSources = []; }

                    const storedReadItemsText = localStorage.getItem(READ_ITEMS_STORAGE_KEY_OLD);
                    const oldReadItems = storedReadItemsText ? JSON.parse(storedReadItemsText) : {};
                    readItems = {};
                    for (const key in oldReadItems) {
                        readItems[sanitizeFirebaseKey(key)] = oldReadItems[key];
                    }

                    if (feedSources.length > 0 || Object.keys(readItems).length > 0) {
                        console.log("Dados do localStorage antigo carregados. Enviando para a nuvem.");
                        await saveDataToFirebase(true);
                        showToast("Dados locais enviados para a nuvem.", "info");
                    } else {
                        console.log("Nenhum dado local (antigo) encontrado para popular a nuvem.");
                        localDataHash = JSON.stringify({ feedSources: [], readItems: {} });
                        lastKnownFirebaseDataHash = localDataHash;
                    }
                }
                cleanupOldReadItems();
                return true;
            } catch (error) {
                console.error("Erro ao carregar dados iniciais do Firebase:", error);
                showToast("Erro ao carregar dados da nuvem. Usando dados locais se disponíveis.", "error");
                const storedSourcesText = localStorage.getItem(FEED_SOURCES_STORAGE_KEY_OLD);
                if (storedSourcesText) feedSources = JSON.parse(storedSourcesText); else feedSources = [];

                const storedReadItemsText = localStorage.getItem(READ_ITEMS_STORAGE_KEY_OLD);
                const oldReadItemsFallback = storedReadItemsText ? JSON.parse(storedReadItemsText) : {};
                readItems = {};
                for (const key in oldReadItemsFallback) {
                    readItems[sanitizeFirebaseKey(key)] = oldReadItemsFallback[key];
                }
                cleanupOldReadItems();
                localDataHash = JSON.stringify({ feedSources, readItems });
                return false;
            } finally {
                firebaseLoadingIndicator.classList.add('hidden');
            }
        }

        function setupFirebaseListener() {
            if (!currentUserSeed || !database || firebaseListenerAttached || !currentDbRef) return;

            window.fbServices.onValue(currentDbRef, (snapshot) => {
                if (isSyncing) return;

                if (!snapshot.exists()) {
                    console.log("Dados removidos do Firebase ou seed vazia. Verifique outros dispositivos.");
                    if (localDataHash !== JSON.stringify({ feedSources: [], readItems: {} })) {
                        showToast("Dados não encontrados na nuvem para esta seed.", "warning");
                    }
                    return;
                }
                const firebaseData = snapshot.val();
                const newFirebaseDataHash = JSON.stringify(firebaseData);

                if (newFirebaseDataHash === localDataHash || newFirebaseDataHash === lastKnownFirebaseDataHash) {
                    return;
                }

                console.log("Dados atualizados recebidos do Firebase.");
                isSyncing = true;
                feedSources = firebaseData.feedSources || [];

                const newReadItems = firebaseData.readItems || {};
                readItems = {};
                for (const key in newReadItems) {
                    readItems[sanitizeFirebaseKey(key)] = newReadItems[key];
                }

                cleanupOldReadItems();

                localDataHash = newFirebaseDataHash;
                lastKnownFirebaseDataHash = newFirebaseDataHash;

                renderSidebarFeedList();
                loadFeeds(currentlyDisplayedFeedUrl);
                showToast("Dados sincronizados da nuvem!", "info", 2000);
                isSyncing = false;
            }, (error) => {
                console.error("Erro no listener do Firebase:", error);
                showToast("Erro de sincronização com a nuvem.", "error");
            });
            firebaseListenerAttached = true;
            console.log("Listener do Firebase configurado para seed:", currentUserSeed);
        }

        async function saveDataToFirebase(isInitialPush = false) {
            if (!currentUserSeed || !database || !currentDbRef) {
                 console.warn("Tentativa de salvar no Firebase sem seed, DB ou ref inicializado.");
                 return;
            }
            if (isSyncing && !isInitialPush) return;

            const currentLocalData = {
                feedSources: feedSources.map(s => ({ url: s.url, name: s.name })),
                readItems: readItems
            };
            const newLocalDataHash = JSON.stringify(currentLocalData);

            if (newLocalDataHash === lastKnownFirebaseDataHash && !isInitialPush) {
                return;
            }

            isSyncing = true;
            firebaseLoadingIndicator.classList.remove('hidden');
            console.log("Enviando dados para o Firebase...");
            try {
                await window.fbServices.set(currentDbRef, currentLocalData);
                localDataHash = newLocalDataHash;
                lastKnownFirebaseDataHash = newLocalDataHash;
                console.log("Dados salvos no Firebase com sucesso.");
                if(!isInitialPush) showToast("Alterações salvas na nuvem.", "success", 1500);
            } catch (error) {
                console.error("Erro ao salvar dados no Firebase:", error);
                showToast(`Erro ao salvar: ${error.message}. Verifique o console.`, "error");
            } finally {
                isSyncing = false;
                firebaseLoadingIndicator.classList.add('hidden');
            }
        }

        function periodicSyncCheck() {
            if (!currentUserSeed || !database || isSyncing) return;

            const currentLocalDataForCheck = {
                feedSources: feedSources.map(s => ({ url: s.url, name: s.name })),
                readItems: readItems
            };
            const currentLocalHashForCheck = JSON.stringify(currentLocalDataForCheck);

            if (currentLocalHashForCheck !== lastKnownFirebaseDataHash) {
                console.log("Periodic sync: Detectada alteração local não sincronizada. Enviando...");
                saveDataToFirebase();
            }
        }

        function cleanupOldReadItems() {
            const now = Date.now();
            let changed = false;
            for (const itemId in readItems) {
                if (now - readItems[itemId] > READ_ITEM_EXPIRY_MS) {
                    delete readItems[itemId];
                    changed = true;
                }
            }
            if (changed && currentUserSeed) {
                 saveDataToFirebase();
            }
        }

        function isItemRead(item) {
            const itemId = getItemId(item);
            return readItems.hasOwnProperty(itemId);
        }

        function toggleReadStatus(item) {
            const itemId = getItemId(item);
            if (!itemId) {
                console.error("Não foi possível obter um ID válido para o item:", item);
                showToast("Erro: ID do item inválido.", "error");
                return;
            }
            const wasRead = isItemRead(item);

            if (wasRead) {
                delete readItems[itemId];
            } else {
                readItems[itemId] = Date.now();
            }

            saveDataToFirebase();

            if (currentItemInModal && getItemId(currentItemInModal) === itemId) {
                updateModalMarkAsReadButtonText();
                if (!wasRead) closeModal();
            }
            loadFeeds(currentlyDisplayedFeedUrl);
        }

        function updateSidebarActiveState() {
            sidebarFeedListContainer.querySelectorAll('.sidebar-item-name').forEach(item => {
                item.classList.toggle('active-feed', item.dataset.feedUrl === currentlyDisplayedFeedUrl);
            });
        }

        function renderSidebarFeedList() {
            sidebarFeedListContainer.innerHTML = '';
            if (!feedSources || feedSources.length === 0) {
                sidebarFeedListContainer.innerHTML = '<p class="sidebar-empty-message">Nenhuma fonte. Importe um OPML ou adicione manualmente.</p>';
                return;
            }
            const sortedSources = [...feedSources].sort((a,b) => (a.name || "").localeCompare(b.name || ""));

            sortedSources.forEach(source => {
                const listItem = document.createElement('div');
                listItem.className = 'sidebar-item';
                const nameAndNsfwContainer = document.createElement('div');
                nameAndNsfwContainer.className = 'sidebar-item-name-container';
                const nameSpan = document.createElement('span');
                nameSpan.textContent = source.name;
                nameSpan.title = source.url;
                nameSpan.dataset.feedUrl = source.url;
                nameSpan.className = 'sidebar-item-name';
                nameSpan.onclick = () => handleSidebarFeedClick(source.url);
                nameAndNsfwContainer.appendChild(nameSpan);
                listItem.appendChild(nameAndNsfwContainer);
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'sidebar-item-actions';
                const configButton = document.createElement('button');
                configButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826 3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>`;
                configButton.title = "Configurar Fonte";
                configButton.onclick = (e) => { e.stopPropagation(); openEditSourceModal(source); };
                actionsDiv.appendChild(configButton);
                const deleteButton = document.createElement('button');
                deleteButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>`;
                deleteButton.title = "Excluir Fonte";
                deleteButton.onclick = (e) => { e.stopPropagation(); promptDeleteFeed(source.url, source.name); };
                actionsDiv.appendChild(deleteButton);
                listItem.appendChild(actionsDiv);
                sidebarFeedListContainer.appendChild(listItem);
            });
            updateSidebarActiveState();
        }

        function handleSidebarFeedClick(clickedUrl) {
            currentlyDisplayedFeedUrl = (currentlyDisplayedFeedUrl === clickedUrl) ? null : clickedUrl;
            loadFeeds(currentlyDisplayedFeedUrl);
             if (window.innerWidth < 768 && sidebar.classList.contains('sidebar-visible-mobile')) {
                sidebar.classList.remove('sidebar-visible-mobile');
                sidebarToggleIconOpen.classList.remove('hidden');
                sidebarToggleIconClose.classList.add('hidden');
            }
        }

        function openEditSourceModal(source) {
            editSourceNameInput.value = source.name;
            editSourceUrlHidden.value = source.url;
            editSourceModal.classList.remove('hidden');
            requestAnimationFrame(() => editSourceModal.classList.add('modal-visible'));
            document.body.style.overflow = 'hidden';
        }

        function closeEditSourceModal() {
            editSourceModal.classList.remove('modal-visible');
            setTimeout(() => editSourceModal.classList.add('hidden'), 300);
            document.body.style.overflow = 'auto';
        }

        saveEditSourceButton.addEventListener('click', () => {
            const url = editSourceUrlHidden.value;
            const sourceToEdit = feedSources.find(s => s.url === url);
            if (sourceToEdit) {
                sourceToEdit.name = editSourceNameInput.value.trim() || new URL(url).hostname;
                saveDataToFirebase();
                renderSidebarFeedList();
                if (currentlyDisplayedFeedUrl === url) {
                    loadFeeds(url);
                }
            }
            closeEditSourceModal();
            showToast("Fonte atualizada com sucesso!", "success");
        });

        async function handleAddFeedEvent() {
            const newUrl = sidebarNewFeedUrlInput.value.trim();
            let newName = sidebarNewFeedNameInput.value.trim();
            if (!newUrl) { showToast('Por favor, insira uma URL de feed válida.', 'error'); return; }
            try { new URL(newUrl); } catch (_) { showToast('A URL inserida não parece ser válida.', 'error'); return; }
            if (feedSources.some(source => source.url === newUrl)) { showToast('Esta URL de feed já foi adicionada.', 'error'); return; }

            const originalButtonText = sidebarAddFeedButton.textContent;
            sidebarAddFeedButton.textContent = 'Adicionando...';
            sidebarAddFeedButton.disabled = true;

            if (!newName) {
                try {
                    const feedData = await fetchFeedData(newUrl, true);
                    newName = (feedData && feedData.feed && feedData.feed.title) ? feedData.feed.title : new URL(newUrl).hostname;
                } catch (error) { newName = new URL(newUrl).hostname; }
            }

            sidebarAddFeedButton.textContent = originalButtonText;
            sidebarAddFeedButton.disabled = false;

            feedSources.push({ url: newUrl, name: newName });
            saveDataToFirebase();
            renderSidebarFeedList();
            sidebarNewFeedUrlInput.value = '';
            sidebarNewFeedNameInput.value = '';
            addFeedForm.classList.add('hidden');
            currentlyDisplayedFeedUrl = newUrl;
            loadFeeds(newUrl);
            showToast(`Feed "${newName}" adicionado com sucesso!`, 'success');
        }

        async function fetchFeedData(rssUrl, bypassCache = false) {
            const cacheKey = CACHE_KEY_PREFIX + rssUrl;
            const apiUrl = `https://api.rss2json.com/v1/api.json?rss_url=${encodeURIComponent(rssUrl)}`;
            const TWENTY_MINUTES_MS = 20 * 60 * 1000;
            let cachedItem = null;
            try {
                const cachedDataString = localStorage.getItem(cacheKey);
                if (cachedDataString) cachedItem = JSON.parse(cachedDataString);
            } catch (e) {
                try { localStorage.removeItem(cacheKey); } catch (removeError) { /* ignore */ }
                cachedItem = null; console.error("Erro ao ler cache:", e);
            }
            const dataExistsInCache = cachedItem && cachedItem.data;
            const lastSuccessfulFetchTimestamp = dataExistsInCache ? (cachedItem.lastNetworkFetchTimestamp || 0) : 0;
            const cacheIsFreshEnoughForDirectServe = Date.now() - lastSuccessfulFetchTimestamp < TWENTY_MINUTES_MS;
            if (!bypassCache && dataExistsInCache && cacheIsFreshEnoughForDirectServe) {
                return { ...(cachedItem.data), fromCache: true, feedUrl: rssUrl, feedTitle: cachedItem.data.feed.title || new URL(rssUrl).hostname };
            }
            try {
                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error(`Erro HTTP: ${response.status} para ${rssUrl}`);
                const freshData = await response.json();
                if (freshData.status !== 'ok') throw new Error(`API rss2json retornou erro: ${freshData.message || 'Erro desconhecido'} para ${rssUrl}`);
                try {
                    localStorage.setItem(cacheKey, JSON.stringify({ data: freshData, timestamp: Date.now(), lastNetworkFetchTimestamp: Date.now() }));
                } catch (e) { console.error("Erro ao salvar no cache:", e); showToast("Erro ao salvar dados no cache local.", "error");}
                return { ...freshData, fromCache: false, feedUrl: rssUrl, feedTitle: freshData.feed.title || new URL(rssUrl).hostname };
            } catch (networkError) {
                if (dataExistsInCache) {
                    const cacheTimestamp = cachedItem.timestamp || 0;
                    const isCacheValidForFallback = Date.now() - cacheTimestamp < CACHE_DURATION_MS;
                    if (isCacheValidForFallback) {
                        return { ...(cachedItem.data), fromCache: true, fromCacheOnError: true, originalError: networkError.message, feedUrl: rssUrl, feedTitle: cachedItem.data.feed.title || new URL(rssUrl).hostname };
                    } else {
                         try { localStorage.removeItem(cacheKey); } catch (e) { /* ignore */ }
                    }
                }
                return { error: networkError.message, feedUrl: rssUrl, feedTitle: new URL(rssUrl).hostname };
            }
        }

        async function handleOpmlImport(event) {
            const file = event.target.files[0];
            if (!file) { showToast('Nenhum arquivo selecionado.', 'error'); return; }
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const opmlContent = e.target.result;
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(opmlContent, "text/xml");
                    const outlines = xmlDoc.querySelectorAll('body > outline[type="rss"][xmlUrl]');
                    if (outlines.length === 0) {
                        showToast('Nenhum feed RSS encontrado no arquivo OPML. Verifique se os feeds têm o atributo type="rss" e xmlUrl.', 'warning');
                        return;
                    }
                    let importedCount = 0; let existingCount = 0; let newSources = [];
                    outlines.forEach(outline => {
                        const xmlUrl = outline.getAttribute('xmlUrl');
                        let title = outline.getAttribute('title') || outline.getAttribute('text');
                        if (!title && xmlUrl) { try { title = new URL(xmlUrl).hostname; } catch (_) { title = "Feed Desconhecido"; } }
                        else if (!title) title = "Feed Desconhecido";
                        if (xmlUrl && !feedSources.some(s => s.url === xmlUrl)) {
                            newSources.push({ url: xmlUrl, name: title });
                            importedCount++;
                        } else if (xmlUrl) existingCount++;
                    });
                    if (newSources.length > 0) {
                        feedSources.push(...newSources);
                        saveDataToFirebase();
                        renderSidebarFeedList();
                        loadFeeds();
                        showToast(`${importedCount} feed(s) importado(s) com sucesso!`, 'success');
                    } else if (existingCount > 0 && importedCount === 0) {
                        showToast('Todos os feeds do arquivo OPML já existem na sua lista.', 'info');
                    } else if (outlines.length > 0 && importedCount === 0 && existingCount === 0) {
                        showToast('Nenhum novo feed RSS válido encontrado para importar.', 'info');
                    }
                } catch (error) {
                    console.error("Erro ao processar arquivo OPML:", error);
                    showToast('Erro ao processar o arquivo OPML. Verifique o formato do arquivo.', 'error');
                } finally { opmlImportInput.value = ''; }
            };
            reader.onerror = () => { showToast('Erro ao ler o arquivo.', 'error'); opmlImportInput.value = ''; };
            reader.readAsText(file);
        }

        function extractImageFromItem(item) {
            console.log('Attempting to extract image from item:', JSON.stringify(item));
            if (!item) return null;
            if (item.thumbnail && typeof item.thumbnail === 'string' && item.thumbnail.startsWith('http')) {
                return item.thumbnail;
            }
            if (item.enclosure && typeof item.enclosure === 'object' && item.enclosure.link && item.enclosure.type && item.enclosure.type.startsWith('image')) {
                return item.enclosure.link;
            }
            if (Array.isArray(item.enclosure)) {
                for (const enc of item.enclosure) {
                    if (typeof enc === 'object' && enc.link && enc.type && enc.type.startsWith('image')) {
                        return enc.link;
                    }
                }
            }
            const mediaNamespaceKeys = Object.keys(item).filter(key => key.startsWith('media:'));
            if (mediaNamespaceKeys.length > 0) {
                const mediaContent = item['media:content'];
                if (mediaContent) {
                    if (Array.isArray(mediaContent)) {
                        for (const media of mediaContent) {
                            if (media.$ && media.$.url && media.$.type && media.$.type.startsWith('image')) return media.$.url;
                            if (media.$ && media.$.url && media.$.medium === 'image') return media.$.url;
                        }
                    } else if (typeof mediaContent === 'object' && mediaContent.$ && mediaContent.$.url) {
                         if ((mediaContent.$.type && mediaContent.$.type.startsWith('image')) || mediaContent.$.medium === 'image') {
                            return mediaContent.$.url;
                        }
                    }
                }
                const mediaThumbnail = item['media:thumbnail'];
                 if (mediaThumbnail && mediaThumbnail.$ && mediaThumbnail.$.url) {
                    return mediaThumbnail.$.url;
                }
            }
            const contentSources = [item.content, item.description];
            for (const sourceHtml of contentSources) {
                if (sourceHtml && typeof sourceHtml === 'string') {
                    try {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = DOMPurify.sanitize(sourceHtml, { USE_PROFILES: { html: true } });
                        const imgTag = tempDiv.querySelector('img');
                        // Check if imgTag and imgTag.src exist, and if src is http(s) or data URI
                        if (imgTag && imgTag.src && (imgTag.src.startsWith('http') || imgTag.src.startsWith('data:image'))) {
                            return imgTag.src; // Return the src if valid
                        }
                    } catch (e) {
                        // console.warn("Error parsing HTML for image:", e);
                    }
                }
            }
            console.log('Failed to extract image from item:', JSON.stringify(item));
            return null;
        }

        function createCard(item) {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'feed-card';
            if (isItemRead(item)) cardDiv.classList.add('is-read');
            cardDiv.addEventListener('click', () => openModal(item));

            const imageUrl = extractImageFromItem(item);
            if (imageUrl) {
                const imageContainer = document.createElement('div');
                imageContainer.className = 'feed-card-image-container';
                const img = document.createElement('img');
                img.src = imageUrl;
                img.alt = item.title || 'Imagem do feed';
                img.className = 'feed-card-image';
                img.onerror = function() {
                    this.style.display = 'none';
                };
                imageContainer.appendChild(img);
                cardDiv.appendChild(imageContainer);
            }

            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'feed-card-content-wrapper';

            const sourceNameBar = document.createElement('div');
            sourceNameBar.className = 'sourceNameBar';
            sourceNameBar.textContent = item.sourceName || 'Fonte Desconhecida';
            sourceNameBar.title = item.sourceName || 'Fonte Desconhecida';
            contentWrapper.appendChild(sourceNameBar);

            const titleElement = document.createElement('h2');
            titleElement.textContent = item.title || 'Título indisponível';
            contentWrapper.appendChild(titleElement);

            cardDiv.appendChild(contentWrapper);

            return cardDiv;
        }

        function displayErrorMessage(feedUrl, errorMessage, feedTitleGiven) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message-item';
            errorDiv.innerHTML = `
                <strong>Erro ao carregar feed:</strong>
                <span>${DOMPurify.sanitize(feedTitleGiven || feedUrl)}</span>
                <p>${DOMPurify.sanitize(errorMessage)}</p>
            `;
            errorMessagesContainer.appendChild(errorDiv);
        }

        function updateModalMarkAsReadButtonText() {
            if (currentItemInModal) {
                const isRead = isItemRead(currentItemInModal);
                modalMarkAsReadButton.textContent = isRead ? "Marcar como Não Lido" : "Marcar como Lido";
                modalMarkAsReadButton.className = '';
                if (isRead) modalMarkAsReadButton.classList.add('mark-unread-button');
                else modalMarkAsReadButton.classList.add('mark-read-button');
            }
        }

        function openModal(item) {
            currentItemInModal = item;
            modalTitleEl.textContent = item.title || "Sem Título";
            modalContent.innerHTML = DOMPurify.sanitize(item.content || item.description || "<p>Conteúdo não disponível.</p>", { USE_PROFILES: { html: true } });
            updateModalMarkAsReadButtonText();
            if(item.link) {
                modalOriginalLink.href = item.link;
                modalOriginalLink.style.display = 'inline-flex';
            } else {
                modalOriginalLink.style.display = 'none';
            }
            feedItemModal.classList.remove('hidden');
            requestAnimationFrame(() => feedItemModal.classList.add('modal-visible'));
            document.body.style.overflow = 'hidden';
        }

        function closeModal() {
            feedItemModal.classList.remove('modal-visible');
            setTimeout(() => feedItemModal.classList.add('hidden'), 300);
            document.body.style.overflow = 'auto';
            currentItemInModal = null;
        }

        function promptDeleteFeed(url, name) {
            feedUrlToDelete = url;
            feedNameToDeleteSpan.textContent = name || url;
            deleteConfirmationModal.classList.remove('hidden');
            requestAnimationFrame(() => deleteConfirmationModal.classList.add('modal-visible'));
            document.body.style.overflow = 'hidden';
        }

        function closeDeleteConfirmationModal() {
            deleteConfirmationModal.classList.remove('modal-visible');
            setTimeout(() => deleteConfirmationModal.classList.add('hidden'), 300);
            document.body.style.overflow = 'auto';
            feedUrlToDelete = null;
        }

        function confirmFeedDeletion() {
            if (!feedUrlToDelete) return;
            const feedIndex = feedSources.findIndex(s => s.url === feedUrlToDelete);
            if (feedIndex > -1) {
                const deletedFeedName = feedSources[feedIndex].name;
                feedSources.splice(feedIndex, 1);
                saveDataToFirebase();
                renderSidebarFeedList();
                try { localStorage.removeItem(CACHE_KEY_PREFIX + feedUrlToDelete); }
                catch (e) { console.error(`Erro ao remover cache para ${feedUrlToDelete}:`, e); }

                if (currentlyDisplayedFeedUrl === feedUrlToDelete) {
                    currentlyDisplayedFeedUrl = null;
                    loadFeeds();
                } else if (currentlyDisplayedFeedUrl === null) {
                    loadFeeds();
                }
                showToast(`Feed "${deletedFeedName}" excluído com sucesso.`, 'success');
            } else {
                showToast("Não foi possível encontrar o feed para excluir.", "error");
            }
            closeDeleteConfirmationModal();
        }

        async function loadFeeds(sourceUrl = null) {
            currentlyDisplayedFeedUrl = sourceUrl;
            updateSidebarActiveState();
            loadingIndicator.classList.remove('hidden');
            feedsContainer.innerHTML = '';
            errorMessagesContainer.innerHTML = '';

            if (feedSources.length === 0) {
                loadingIndicator.classList.add('hidden');
                feedsContainer.innerHTML = '<p class="empty-state-message">Nenhuma fonte de feed configurada. Importe um arquivo OPML ou adicione uma fonte manualmente.</p>';
                return;
            }

            let feedsToFetchFrom = sourceUrl ? feedSources.filter(s => s.url === sourceUrl) : [...feedSources];

            if (sourceUrl && feedsToFetchFrom.length === 0) {
                loadingIndicator.classList.add('hidden');
                feedsContainer.innerHTML = `<p class="empty-state-message">Nenhum item para esta seleção ou a fonte foi removida.</p>`;
                currentlyDisplayedFeedUrl = null;
                updateSidebarActiveState();
                return;
            }

            let allFetchedRawItems = [];
            const promises = feedsToFetchFrom.map(source => fetchFeedData(source.url));
            const results = await Promise.allSettled(promises);

            results.forEach(result => {
                if (result.status === 'fulfilled' && result.value) {
                    const feedResponse = result.value;
                    if (feedResponse.error) {
                        displayErrorMessage(feedResponse.feedUrl, feedResponse.error, feedResponse.feedTitle);
                    } else if (feedResponse.items && feedResponse.items.length > 0) {
                        const sourceOrigin = feedSources.find(s => s.url === feedResponse.feedUrl);
                        const sourceNameForItems = feedResponse.feed.title || (sourceOrigin ? sourceOrigin.name : (feedResponse.feedUrl ? new URL(feedResponse.feedUrl).hostname : 'Fonte Desconhecida'));
                        feedResponse.items.forEach(item => {
                            let pubDateTimestamp = item.pubDate ? new Date(item.pubDate).getTime() : 0;
                            if (isNaN(pubDateTimestamp) || pubDateTimestamp === 0) {
                                if (item.published && !isNaN(new Date(item.published).getTime())) {
                                     pubDateTimestamp = new Date(item.published).getTime();
                                } else if (item.updated && !isNaN(new Date(item.updated).getTime())) {
                                     pubDateTimestamp = new Date(item.updated).getTime();
                                }
                            }
                            allFetchedRawItems.push({ ...item, parsedPubDateTimestamp: pubDateTimestamp, sourceName: sourceNameForItems });
                        });
                    }
                } else if (result.status === 'rejected') {
                    const failedSource = feedsToFetchFrom.find(s => result.reason && typeof result.reason.message === 'string' && result.reason.message.includes(s.url));
                    const errorMessageText = result.reason ? (result.reason.message || String(result.reason)) : 'Falha desconhecida ao buscar um feed.';
                    displayErrorMessage(failedSource ? failedSource.url : "URL Desconhecida", errorMessageText, failedSource ? failedSource.name : "Feed Desconhecido");
                }
            });

            allFetchedRawItems.sort((a, b) => (b.parsedPubDateTimestamp || 0) - (a.parsedPubDateTimestamp || 0));

            const threeDaysAgo = new Date();
            threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);
            threeDaysAgo.setHours(0, 0, 0, 0);
            const threeDaysAgoTimestamp = threeDaysAgo.getTime();

            const itemsFromLastThreeDays = allFetchedRawItems.filter(item => {
                if (!item.parsedPubDateTimestamp || isNaN(item.parsedPubDateTimestamp) || item.parsedPubDateTimestamp <= 0) {
                    return false;
                }
                return item.parsedPubDateTimestamp >= threeDaysAgoTimestamp;
            });

            loadingIndicator.classList.add('hidden');

            if (itemsFromLastThreeDays.length === 0) {
                if (errorMessagesContainer.children.length === 0) {
                    let emptyMsg = "Nenhum item novo nos últimos 3 dias.";
                    if (sourceUrl) {
                        const source = feedSources.find(s => s.url === sourceUrl);
                        emptyMsg = `Nenhum item novo nos últimos 3 dias para "${source ? source.name : 'esta seleção'}".`;
                    }
                    feedsContainer.innerHTML = `<p class="empty-state-message">${emptyMsg}</p>`;
                } else if (feedsContainer.innerHTML === '') {
                     feedsContainer.innerHTML = `<p class="empty-state-message">Nenhum item para exibir após considerar os erros e o filtro de data.</p>`;
                }
                return;
            }

            const unreadItems = itemsFromLastThreeDays.filter(item => !isItemRead(item));
            const readItemsInScope = itemsFromLastThreeDays.filter(item => isItemRead(item));

            if (unreadItems.length === 0) {
                feedsContainer.innerHTML = `<p class="empty-state-message">Você está atualizado!</p>`;
            } else {
                const itemsToDisplay = [
                    ...unreadItems,
                    ...readItemsInScope
                ].slice(0, MAX_FEEDS_DISPLAY);

                const gridDiv = document.createElement('div');
                gridDiv.className = 'grid';
                itemsToDisplay.forEach((item) => {
                    gridDiv.appendChild(createCard(item));
                });
                feedsContainer.appendChild(gridDiv);
            }
        }

        function cleanupOrphanedCacheEntries() {
            const currentFeedUrls = new Set(feedSources.map(s => s.url));
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith(CACHE_KEY_PREFIX)) {
                    const cachedUrl = key.substring(CACHE_KEY_PREFIX.length);
                    if (!currentFeedUrls.has(cachedUrl)) {
                        try { localStorage.removeItem(key); }
                        catch (e) { console.error(`Erro ao remover cache órfão ${key}:`, e); }
                    }
                }
            }
        }

        async function initializeAppLogic() {
            firebaseLoadingIndicator.classList.remove('hidden');
            const firebaseReady = await initializeFirebase();
            if (firebaseReady && currentUserSeed) {
                if (firebaseListenerAttached && currentDbRef && window.fbServices.off) {
                     window.fbServices.off(currentDbRef);
                     firebaseListenerAttached = false;
                     console.log("Listener antigo removido antes de inicializar nova lógica de app.");
                }
                await loadInitialDataFromFirebase();
                setupFirebaseListener();
            } else if (!currentUserSeed) {
                console.log("Nenhuma seed configurada. Aguardando configuração.");
                firebaseLoadingIndicator.classList.add('hidden');
                showSeedModal();
                return;
            } else {
                showToast("Sincronização offline. Verifique a conexão ou configuração.", "error");
                const storedSourcesText = localStorage.getItem(FEED_SOURCES_STORAGE_KEY_OLD);
                if (storedSourcesText) feedSources = JSON.parse(storedSourcesText); else feedSources = [];

                const storedReadItemsText = localStorage.getItem(READ_ITEMS_STORAGE_KEY_OLD);
                const oldReadItemsFallback = storedReadItemsText ? JSON.parse(storedReadItemsText) : {};
                readItems = {};
                for (const key in oldReadItemsFallback) {
                    readItems[sanitizeFirebaseKey(key)] = oldReadItemsFallback[key];
                }
                cleanupOldReadItems();
                localDataHash = JSON.stringify({ feedSources, readItems });
                 firebaseLoadingIndicator.classList.add('hidden');
            }

            cleanupOrphanedCacheEntries();
            renderSidebarFeedList();
            loadFeeds();

            setInterval(periodicSyncCheck, 60 * 1000);
            firebaseLoadingIndicator.classList.add('hidden');
        }

        document.addEventListener('DOMContentLoaded', () => {
            const storedSeed = localStorage.getItem(SEED_STORAGE_KEY);
            if (storedSeed && SEED_PATTERN.test(storedSeed)) {
                currentUserSeed = storedSeed;
                displayCurrentSeedElement(currentUserSeed);
                initializeAppLogic();
            } else {
                showSeedModal();
            }

            opmlImportButton.addEventListener('click', () => opmlImportInput.click());
            opmlImportInput.addEventListener('change', handleOpmlImport);

            sidebarToggle.addEventListener('click', () => {
                if (window.innerWidth < 768) {
                    sidebar.classList.toggle('sidebar-visible-mobile');
                } else {
                    sidebar.classList.toggle('sidebar-hidden');
                    mainContent.classList.toggle('sidebar-hidden', sidebar.classList.contains('sidebar-hidden'));
                }
                const isOpen = sidebar.classList.contains('sidebar-visible-mobile') ||
                               (window.innerWidth >= 768 && !sidebar.classList.contains('sidebar-hidden'));
                sidebarToggleIconOpen.classList.toggle('hidden', isOpen);
                sidebarToggleIconClose.classList.toggle('hidden', !isOpen);
            });

            toggleAddFeedFormButton.addEventListener('click', () => addFeedForm.classList.toggle('hidden'));
            sidebarAddFeedButton.addEventListener('click', handleAddFeedEvent);
            [sidebarNewFeedUrlInput, sidebarNewFeedNameInput].forEach(input => {
                input.addEventListener('keypress', (e) => { if (e.key === 'Enter') sidebarAddFeedButton.click(); });
            });

            closeEditSourceModalButton.addEventListener('click', closeEditSourceModal);
            cancelEditSourceButton.addEventListener('click', closeEditSourceModal);
            modalMarkAsReadButton.addEventListener('click', () => { if (currentItemInModal) toggleReadStatus(currentItemInModal); });
            closeModalButton.addEventListener('click', closeModal);
            feedItemModal.addEventListener('click', (event) => { if (event.target === feedItemModal) closeModal(); });
            editSourceModal.addEventListener('click', (event) => { if (event.target === editSourceModal) closeEditSourceModal(); });
            closeDeleteConfirmationModalButton.addEventListener('click', closeDeleteConfirmationModal);
            cancelDeleteFeedButton.addEventListener('click', closeDeleteConfirmationModal);
            confirmDeleteFeedButton.addEventListener('click', confirmFeedDeletion);
            deleteConfirmationModal.addEventListener('click', (event) => { if (event.target === deleteConfirmationModal) closeDeleteConfirmationModal(); });

            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    if (feedItemModal.classList.contains('modal-visible')) closeModal();
                    if (editSourceModal.classList.contains('modal-visible')) closeEditSourceModal();
                    if (deleteConfirmationModal.classList.contains('modal-visible')) closeDeleteConfirmationModal();
                    if (seedModal.classList.contains('modal-visible') && !document.getElementById('closeSeedModalButton').style.display) hideSeedModal();
                }
            });
        });
    </script>
</body>
</html>
